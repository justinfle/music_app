# Musikverwaltung und Algorithmus-Analyse
## 1. Einleitung
Dieses Projekt besch√§ftigt sich mit der Entwicklung einer textbasierten Musikverwaltungsanwendung, die eine umfangreiche Sammlung von Musiktiteln und Playlists erm√∂glicht. Der Fokus des Projekts liegt darauf, verschiedene Such- und Sortieralgorithmen zu implementieren und deren Leistung auf gro√üe Datenmengen zu testen. Die Anwendung bietet Funktionen zum Erstellen, Verwalten und Durchsuchen von Songs und Playlists sowie zur Analyse der Effizienz von Algorithmen. Die gesamte Benutzeroberfl√§che basiert auf einer textbasierten Men√ºf√ºhrung, die f√ºr verschiedene Operationen der Musikverwaltung verwendet wird.

## 2. Konzept und Vorgehensweise
### Das Projekt besteht aus zwei Hauptkomponenten:

CSV-Datei mit Musiktiteln: Es wurde eine CSV-Datei (charts_renew_large.csv) erstellt, die 100.000 vollst√§ndig einzigartige Songtitel enth√§lt. Diese Datei stellt die Grundlage der Musiksammlung dar. Jeder Songtitel hat individuelle Eigenschaften wie Name, K√ºnstler, Album, Genre und Dauer. Diese Datei wurde speziell erstellt, um keine Dopplungen in den Songnamen zu enthalten.

Python-Code zur Verwaltung und Analyse: Der Hauptcode der Anwendung ist in Python geschrieben und enth√§lt Klassen und Methoden f√ºr das Laden, Speichern und Verwalten der Musiktitel sowie f√ºr die Durchf√ºhrung von Sortier- und Suchoperationen. Die Anwendung wird beim Starten der Datei music_app.py ausgef√ºhrt und l√§dt die Musiktitel aus der CSV-Datei in eine interne Datenstruktur. Anschlie√üend bietet das Programm eine textbasierte Men√ºf√ºhrung, um die verschiedenen Funktionen aufzurufen.

### Die Vorgehensweise gliedert sich wie folgt:

Die Erstellung der CSV-Datei umfasst die Generierung von 100.000 einzigartigen Songtiteln durch eine speziell entwickelte Python-Funktion. Diese Funktion kombiniert zuf√§llig ausgew√§hlte W√∂rter, um individuelle Songnamen zu generieren und pr√ºft dabei, dass keine Dopplungen in den Namen auftreten. Dadurch wird sichergestellt, dass jeder Songtitel in der Musiksammlung vollst√§ndig einzigartig ist.

Die Implementierung des Codes erfolgt durch die Definition mehrerer Klassen, darunter Song, Playlist und MusicApp. Jede dieser Klassen besitzt spezifische Methoden, um die Daten zu verwalten. Die Song-Klasse repr√§sentiert einen einzelnen Musiktitel, w√§hrend die Playlist-Klasse Sammlungen von Songs speichert und verwaltet. Die Hauptklasse MusicApp koordiniert alle Interaktionen und Funktionalit√§ten der Anwendung, wie das Laden und Speichern von Daten, das Erstellen von Playlists und die Implementierung von Sortier- und Suchalgorithmen.

Die Einbindung der Sortier- und Suchalgorithmen erfolgt durch die Integration verschiedener Algorithmen, die speziell f√ºr die Verwaltung der Musiksammlung optimiert wurden. Es wurden Algorithmen wie Quicksort, Mergesort und Blocksort zur Sortierung, sowie lineare und bin√§re Suche f√ºr das effiziente Durchsuchen der Musiksammlung implementiert.

Zur abschlie√üenden Leistungsbewertung wurden detaillierte Laufzeitmessungen f√ºr jeden implementierten Algorithmus durchgef√ºhrt. Diese Messungen erm√∂glichen es, die Effizienz der einzelnen Verfahren auf gro√üen Datenmengen zu analysieren und zu vergleichen, wodurch klar wird, welche Algorithmen in verschiedenen Anwendungsf√§llen die besten Ergebnisse erzielen.


## 3. Architektur und Nutzerf√ºhrung
Der Code der Anwendung ist modular aufgebaut und besteht aus drei Hauptklassen, die jeweils unterschiedliche Funktionalit√§ten abdecken und die Struktur der Anwendung klar voneinander trennen:

- Song: Diese Klasse repr√§sentiert die grundlegende Einheit der Musiksammlung ‚Äì einen einzelnen Musiktitel. Jeder Song ist durch die Attribute name, artist, album, genre und duration charakterisiert. Die Song-Klasse dient dazu, die wesentlichen Informationen √ºber jeden Titel strukturiert zu speichern und darzustellen. Diese Attribute sind entscheidend f√ºr die sp√§tere Verwaltung, Suche und Sortierung der Titel.

- Playlist: Diese Klasse ist daf√ºr zust√§ndig, Sammlungen von Song-Objekten zu organisieren. Jede Playlist hat einen eindeutigen Namen und kann beliebig viele Songs enthalten. Die Playlist-Klasse bietet Methoden, um Songs zur Playlist hinzuzuf√ºgen oder daraus zu entfernen. Sie erm√∂glicht au√üerdem das Umbenennen der Playlists. Dadurch wird es einfach, benutzerdefinierte Gruppen von Songs zu erstellen und zu pflegen, was eine bessere Verwaltung und Strukturierung der Musiksammlung erm√∂glicht.

- MusicApp: Die MusicApp-Klasse ist das zentrale Steuerelement der Anwendung, das alle Funktionalit√§ten koordiniert und die Hauptlogik der Software implementiert. Sie ist f√ºr das Laden und Speichern der Daten aus und in die CSV-Datei zust√§ndig, verwaltet Playlists und integriert die verschiedenen Sortier- und Suchalgorithmen. Zus√§tzlich stellt die MusicApp-Klasse die Benutzeroberfl√§che bereit und bietet alle Funktionen der Anwendung √ºber ein interaktives Men√º an. Dies erleichtert die Interaktion mit der Anwendung und sorgt f√ºr eine klare Trennung zwischen der Datenverarbeitung und der Benutzerinteraktion.

### Nutzerf√ºhrung
Die gesamte Benutzerinteraktion erfolgt √ºber eine textbasierte Konsole, in der der Benutzer durch Eingabe von numerischen Men√ºoptionen navigieren kann. Beim Start der Anwendung wird ein Hauptmen√º angezeigt, das die verschiedenen Funktionen der Anwendung √ºbersichtlich pr√§sentiert. Jede Option des Men√ºs f√ºhrt den Benutzer zu einer spezifischen Funktionalit√§t, die in einem separaten Untermen√º ausgef√ºhrt wird. Dabei sind alle Eingabem√∂glichkeiten mit einer kurzen Beschreibung versehen, um den Nutzer intuitiv durch die verschiedenen Schritte zu leiten.

Das Hauptmen√º bietet die folgenden Optionen:

- Add New Song: Diese Option erm√∂glicht es dem Benutzer, einen neuen Song zur bestehenden Musiksammlung hinzuzuf√ºgen. Der Benutzer wird dabei durch eine Reihe von Eingabeaufforderungen gef√ºhrt, bei denen die Details des neuen Songs abgefragt werden. Dies umfasst den Songtitel, den Namen des Interpreten, das Album, das Genre und die L√§nge des Titels.

- Create Playlist: Mit dieser Funktion kann der Benutzer eine neue Playlist erstellen. Hierzu gibt der Benutzer einen Namen f√ºr die Playlist ein. Die neu erstellte Playlist kann anschlie√üend bearbeitet und verwaltet werden, indem Songs hinzugef√ºgt oder entfernt werden.

- Add Song to Playlist: Diese Option erm√∂glicht es, einen bestehenden Song aus der Musiksammlung zu einer bereits vorhandenen Playlist hinzuzuf√ºgen. Der Benutzer muss den Namen der Playlist und den Titel des hinzuzuf√ºgenden Songs eingeben. Sollte der eingegebene Titel oder die Playlist nicht existieren, wird eine Fehlermeldung ausgegeben.

- Search Songs: Mit dieser Option kann der Benutzer die Musiksammlung durchsuchen, indem er einen Suchbegriff eingibt. Die Suche ber√ºcksichtigt sowohl den Songtitel als auch den K√ºnstlernamen. Alle √ºbereinstimmenden Titel werden anschlie√üend in der Konsole angezeigt.

- Advanced Search with Time Measurement: Diese Funktion bietet eine erweiterte Suchm√∂glichkeit, bei der der Benutzer zwischen der linearen und der bin√§ren Suche w√§hlen kann. Nach Auswahl des Suchalgorithmus wird die Zeit gemessen, die f√ºr die Suche ben√∂tigt wird, und das Ergebnis zusammen mit der Laufzeit in der Konsole ausgegeben.

- Sort Songs with Time Measurement: Hier kann der Benutzer zwischen verschiedenen Sortieralgorithmen w√§hlen, um die Musiksammlung neu zu ordnen. Zur Verf√ºgung stehen Quicksort, Mergesort, Bubblesort und Blocksort. Nach der Auswahl wird der ausgew√§hlte Algorithmus auf die gesamte Sammlung angewendet und die Zeit gemessen, die f√ºr die Sortierung ben√∂tigt wird. Die Laufzeit und das sortierte Ergebnis werden dem Benutzer angezeigt.

- Display All Songs: Diese Option zeigt alle aktuell in der Musiksammlung enthaltenen Songs in der Konsole an. Der Benutzer erh√§lt eine vollst√§ndige Liste der Songs mit allen Details wie Titel, Interpret, Album und Genre.

- Display Playlists: Mit dieser Funktion kann der Benutzer alle vorhandenen Playlists anzeigen. Jede Playlist wird mit ihrem Namen und einer Liste der darin enthaltenen Songs dargestellt. Diese Ansicht bietet dem Benutzer eine schnelle √úbersicht √ºber die Struktur und den Inhalt der Playlists.

- Exit: Beendet die Anwendung und speichert automatisch alle √Ñnderungen an der Musiksammlung und den Playlists. Der Benutzer wird dar√ºber informiert, dass die Daten erfolgreich gespeichert wurden, bevor das Programm geschlossen wird.

Die Men√ºf√ºhrung ist bewusst einfach und benutzerfreundlich gestaltet, um eine schnelle und intuitive Navigation zwischen den verschiedenen Funktionen zu erm√∂glichen. Nach jeder durchgef√ºhrten Aktion erh√§lt der Benutzer eine Best√§tigung, damit er stets den aktuellen Zustand der Daten nachvollziehen kann. Fehlerhafte Eingaben werden durch entsprechende Fehlermeldungen abgefangen, sodass der Benutzer problemlos zu einem vorherigen Men√º zur√ºckkehren kann, um seine Eingabe zu korrigieren.

Durch diese klare Struktur und die durchdachte Navigation bietet die Anwendung eine hohe Benutzerfreundlichkeit, selbst bei gro√üen Datenmengen. Die textbasierte Benutzeroberfl√§che ist einfach gehalten, sorgt aber dennoch f√ºr eine reibungslose Interaktion und einen klaren √úberblick √ºber die gesamte Musiksammlung und die Playlists.

## 4. Implementierte Such- und Sortieralgorithmen
### Sortieralgorithmen
1. Quicksort: Quicksort ist ein sehr effizienter und weit verbreiteter Sortieralgorithmus, der eine durchschnittliche Laufzeit von ùëÇ(ùëõlog‚Å°ùëõ) besitzt. Der Algorithmus folgt dem Prinzip des Teile-und-Herrsche-Ansatzes, bei dem die zu sortierende Liste rekursiv in kleinere Teile zerlegt wird. Zun√§chst wird ein sogenanntes Pivot-Element aus der Liste gew√§hlt, das als Referenzpunkt dient. Alle Elemente, die kleiner als das Pivot-Element sind, werden in eine Teilliste links vom Pivot und alle gr√∂√üeren Elemente in eine Teilliste rechts vom Pivot verschoben. Danach wird dieser Vorgang rekursiv auf beide Teillisten angewendet, bis die gesamte Liste sortiert ist. Da der Algorithmus nur sehr wenig zus√§tzlichen Speicher ben√∂tigt und im Allgemeinen sehr schnell ist, wird Quicksort h√§ufig als einer der effizientesten Sortieralgorithmen betrachtet. In bestimmten F√§llen, z.B. wenn das Pivot-Element schlecht gew√§hlt wird, kann die Laufzeit im Worst-Case jedoch auf ùëÇ(ùëõ2) ansteigen. Durch die richtige Wahl des Pivot-Elements kann dies aber meist vermieden werden.

2. Bubblesort: Bubblesort ist einer der einfachsten Sortieralgorithmen und hat eine Laufzeit von ùëÇ(ùëõ2), was ihn f√ºr gr√∂√üere Datenmengen ineffizient macht. Der Name leitet sich von der Idee ab, dass gr√∂√üere Elemente wie Blasen nach oben aufsteigen. Bei jedem Durchlauf der Liste werden benachbarte Elemente miteinander verglichen und vertauscht, wenn das linke Element gr√∂√üer ist als das rechte. Dadurch wandert das gr√∂√üte Element in jeder Iteration "nach oben" und wird an der richtigen Position abgelegt. Dieser Prozess wird so lange wiederholt, bis keine Vertauschungen mehr notwendig sind. Da jeder Durchlauf maximal ein Element korrekt platziert, ben√∂tigt Bubblesort in der Regel viele Iterationen, was bei gro√üen Listen sehr ineffizient ist. Aus diesem Grund wird Bubblesort in der Praxis kaum verwendet und dient h√§ufig nur zu Lehrzwecken, um die Funktionsweise von Sortieralgorithmen zu veranschaulichen.

3. Mergesort: Mergesort ist ein stabiler Sortieralgorithmus, der ebenfalls nach dem Teile-und-Herrsche-Prinzip arbeitet. Er hat eine garantierte Laufzeit von ùëÇ(ùëõlogùëõ), unabh√§ngig von der urspr√ºnglichen Anordnung der Liste. Der Algorithmus teilt die Liste rekursiv in immer kleinere Teillisten, bis jede Teilliste nur noch ein einziges Element enth√§lt. Danach werden die Teillisten in aufsteigender Reihenfolge wieder zusammengef√ºhrt (Merge-Phase), wobei jedes Element nacheinander in die richtige Reihenfolge gebracht wird. Mergesort ist besonders vorteilhaft, wenn Stabilit√§t eine wichtige Rolle spielt, d.h. wenn gleiche Elemente in ihrer Reihenfolge erhalten bleiben sollen. Im Gegensatz zu Quicksort ben√∂tigt Mergesort jedoch zus√§tzlichen Speicher, um die Teillisten w√§hrend der Zusammenf√ºhrung zu speichern, was ihn f√ºr speicherintensive Anwendungen weniger geeignet macht.

4. Blocksort: Blocksort ist ein auf die Blockweise aufgeteiltes Verfahren, das besonders dann effizient ist, wenn die Liste in gr√∂√üere Bl√∂cke unterteilt werden kann. Die Idee hinter Blocksort ist, die Liste zun√§chst in kleinere Bl√∂cke fester Gr√∂√üe zu unterteilen und jeden dieser Bl√∂cke separat zu sortieren. Anschlie√üend werden die sortierten Bl√∂cke durch ein effizientes Merging zusammengef√ºhrt. Diese Methode hat eine Laufzeit von ùëÇ(ùëõlog‚Å°ùëõ), wenn die Blockgr√∂√üe geeignet gew√§hlt wird. Ein gro√üer Vorteil von Blocksort besteht darin, dass er bei bereits teilweise sortierten Daten sehr schnell arbeiten kann, da nur innerhalb der Bl√∂cke sortiert wird und die vorhandene Ordnung weitgehend erhalten bleibt.

### Suchalgorithmen
1. Lineare Suche: Die lineare Suche ist der einfachste Suchalgorithmus, der eine Laufzeit von ùëÇ(ùëõ) aufweist. Der Algorithmus durchl√§uft die Liste von Anfang bis Ende und vergleicht jedes Element mit dem gesuchten Wert. Sobald das gew√ºnschte Element gefunden wird, wird die Suche beendet und das Element zur√ºckgegeben. Falls das gesuchte Element nicht in der Liste vorhanden ist, wird die gesamte Liste einmal durchlaufen. Obwohl die lineare Suche bei kleinen Listen effizient sein kann, ist sie f√ºr gro√üe Datens√§tze eher ungeeignet, da die Anzahl der Vergleiche linear zur Listenl√§nge ansteigt. Daher eignet sich die lineare Suche besonders in F√§llen, bei denen die Liste unsortiert ist oder keine zus√§tzlichen Vorbereitungen (z.B. Sortierung) durchgef√ºhrt werden sollen.

2. Bin√§re Suche (Iterative Version): Die bin√§re Suche ist ein effizienter Suchalgorithmus mit einer durchschnittlichen Laufzeit von ùëÇ(log‚Å°ùëõ), der jedoch nur auf sortierten Listen angewendet werden kann. Der Algorithmus arbeitet nach dem Prinzip des wiederholten Teilens: Er vergleicht das gesuchte Element mit dem mittleren Element der Liste. Ist das gesuchte Element kleiner als das mittlere Element, wird die Suche auf die linke H√§lfte der Liste beschr√§nkt; ist es gr√∂√üer, auf die rechte H√§lfte. Dieser Vorgang wird solange wiederholt, bis entweder das gesuchte Element gefunden oder die verbleibende Liste leer ist. Da die bin√§re Suche die Anzahl der zu durchsuchenden Elemente bei jedem Schritt halbiert, w√§chst die Laufzeit logarithmisch zur Gr√∂√üe der Liste, was sie besonders bei gro√üen sortierten Datenmengen sehr effizient macht. In diesem Projekt wurde die bin√§re Suche als iterative Version implementiert, um eine zu gro√üe Rekursionstiefe zu vermeiden, die bei sehr gro√üen Listen zu Fehlern f√ºhren k√∂nnte.

## 5. Laufzeitanalyse der Algorithmen
Die Laufzeitanalyse f√ºr die Algorithmen wurde unter Verwendung einer gro√üen Sammlung von 100.000 Songs durchgef√ºhrt. Die Ergebnisse sind wie folgt:

- Quicksort: 0.3058 Sekunden
- Bubblesort: 1011.8155 Sekunden
- Mergesort: 8.3915 Sekunden
- Blocksort: 0.0891 Sekunden
- Lineare Suche: 0.0257 Sekunden
- Bin√§re Suche: 1.0579 Sekunden
### Analyse:
Sortieralgorithmen: Quicksort und Blocksort sind deutlich schneller als Bubblesort, was bei gro√üen Datenmengen zu erwarten ist. Mergesort zeigt ebenfalls eine gute Performance, ist aber langsamer als Quicksort aufgrund der zus√§tzlichen Speicheranforderungen. Bubblesort zeigt eine extrem lange Laufzeit, was seine Verwendung f√ºr gro√üe Listen unpraktisch macht.
Suchalgorithmen: Die lineare Suche zeigt eine geringere Laufzeit im Vergleich zur bin√§ren Suche, weil die Bin√§rsuche zun√§chst die Liste sortiert, bevor sie die Suche durchf√ºhrt. Bei einer bereits sortierten Liste w√§re die bin√§re Suche effizienter.

## 6. Zusammenfassung
Dieses Projekt zeigt, wie Such- und Sortieralgorithmen auf eine gro√üe Menge an Musiktiteln angewendet werden k√∂nnen, um deren Effizienz und Leistung zu evaluieren. Die Anwendung bietet eine umfassende Verwaltung von Songs und Playlists und erm√∂glicht es dem Benutzer, die Algorithmen direkt zu testen und zu vergleichen. Die Laufzeitanalyse verdeutlicht die Unterschiede zwischen verschiedenen Algorithmen und zeigt auf, welche Methoden f√ºr gro√üe Datens√§tze geeignet sind.

